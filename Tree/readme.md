# Binary Tree & BST - Complete Index

## ğŸ“‘ Complete Problem Catalog (43 Problems)

---

## ğŸ”¹ **TREE TRAVERSALS**
*Different ways to visit tree nodes*

### **Subtype: Basic Traversals**
1. Inorder Traversal
2. Preorder Traversal
3. Postorder Traversal
4. Level Order Traversal
5. All Three Traversals in One Pass

---

## ğŸ”¹ **TREE PROPERTIES**
*Analyzing tree characteristics*

### **Subtype: Basic Properties**
6. Maximum Depth in Binary Tree
7. Check if Two Trees are Identical
8. Check for Balanced Binary Tree

### **Subtype: Path & Distance**
9. Diameter of Binary Tree
10. Maximum Path Sum
11. Check for Symmetrical Binary Tree

---

## ğŸ”¹ **ADVANCED TRAVERSALS**
*Complex traversal patterns*

### **Subtype: Level-based Views**
12. Zig Zag (Spiral) Traversal
13. Boundary Traversal
14. Vertical Order Traversal
15. Top View of Binary Tree
16. Bottom View of Binary Tree
17. Right/Left View of Binary Tree

### **Subtype: Path & Distance Problems**
18. Print Root to Node Path
19. Print All Nodes at Distance K
20. Minimum Time to Burn Tree

### **Subtype: Width & Counting**
21. Maximum Width of Binary Tree
22. Count Nodes in Complete Binary Tree

---

## ğŸ”¹ **TREE RELATIONSHIPS**
*Node relationships and construction*

### **Subtype: Lowest Common Ancestor**
23. Lowest Common Ancestor (LCA)

### **Subtype: Tree Construction**
24. Requirements to Construct Unique Binary Tree
25. Construct BT from Preorder and Inorder
26. Construct BT from Postorder and Inorder
27. Serialize and Deserialize Binary Tree

---

## ğŸ”¹ **MORRIS TRAVERSAL**
*Space-optimized traversal (O(1) space)*

28. Morris Inorder Traversal
29. Morris Preorder Traversal

---

## ğŸ”¹ **BINARY SEARCH TREE (BST)**
*Special properties of BST*

### **Subtype: BST Basic Operations**
30. Search in BST
31. Floor and Ceil in a BST
32. Insert a given node in BST
33. Delete a node in BST

### **Subtype: Kth Element & Validation**
34. Kth Smallest and Largest element in BST
35. Check if a tree is a BST or not

### **Subtype: BST Advanced**
36. LCA in BST
37. Construct a BST from a preorder traversal
38. Inorder successor and predecessor in BST
39. BST iterator

### **Subtype: BST with Two Pointers**
40. Two sum in BST

### **Subtype: BST Correction & Analysis**
41. Correct BST with two nodes swapped
42. Largest BST in Binary Tree

---

## ğŸ“Š **SUMMARY BY CATEGORY**

### **ğŸŸ¢ Tree Traversals** (5 problems)
â†’ Problems: 1-5

### **ğŸŸ¡ Tree Properties** (6 problems)
â†’ Problems: 6-11

### **ğŸŸ¡ Advanced Traversals** (11 problems)
â†’ Problems: 12-22

### **ğŸ”´ Tree Relationships** (5 problems)
â†’ Problems: 23-27

### **ğŸ”´ Morris Traversal** (2 problems)
â†’ Problems: 28-29

### **ğŸŸ¢ BST Basic** (4 problems)
â†’ Problems: 30-33

### **ğŸŸ¡ BST Advanced** (7 problems)
â†’ Problems: 34-40

### **ğŸ”´ BST Complex** (2 problems)
â†’ Problems: 41-42

---

## ğŸ“ˆ **LEARNING PATH RECOMMENDATION**

### **Phase 1: Basic Traversals** (Start Here)
```
1 â†’ 2 â†’ 3 â†’ 4 â†’ 5
```
*Master all traversal techniques*

### **Phase 2: Tree Properties**
```
6 â†’ 7 â†’ 8 â†’ 9 â†’ 11
```
*Understand tree characteristics*

### **Phase 3: Path Problems**
```
10 â†’ 18 â†’ 23
```
*Learn path-finding techniques*

### **Phase 4: View-based Traversals**
```
12 â†’ 13 â†’ 14 â†’ 15 â†’ 16 â†’ 17
```
*Different perspectives of tree*

### **Phase 5: Advanced Tree Problems**
```
19 â†’ 20 â†’ 21 â†’ 22
```
*Distance and counting problems*

### **Phase 6: Tree Construction**
```
24 â†’ 25 â†’ 26 â†’ 27
```
*Build trees from traversals*

### **Phase 7: Morris Traversal**
```
28 â†’ 29
```
*Space-optimized traversal*

### **Phase 8: BST Basics**
```
30 â†’ 31 â†’ 32 â†’ 33 â†’ 35
```
*BST operations and validation*

### **Phase 9: BST Advanced**
```
34 â†’ 36 â†’ 37 â†’ 38 â†’ 39 â†’ 40
```
*Complex BST problems*

### **Phase 10: BST Correction**
```
41 â†’ 42
```
*Fix and analyze BST*

---

## ğŸ¯ **CONCEPT CLUSTERING**

### **Cluster 1: Traversal Fundamentals**
*Core traversal patterns*
- DFS Traversals: 1, 2, 3
- BFS Traversal: 4
- Combined: 5

### **Cluster 2: Tree Metrics**
*Measuring tree properties*
- Depth/Height: 6, 9
- Balance: 8
- Comparison: 7, 11

### **Cluster 3: Path & Sum**
*Path-based calculations*
- Maximum Sum: 10
- Root to Node: 18
- LCA: 23, 36

### **Cluster 4: View Problems**
*Different tree perspectives*
- Directional Views: 15, 16, 17
- Vertical: 14
- Boundary: 13
- Spiral: 12

### **Cluster 5: Distance & Burning**
*Distance-based problems*
- K Distance: 19
- Burning Time: 20
- Width: 21

### **Cluster 6: Construction & Serialization**
*Building and encoding trees*
- From Traversals: 25, 26, 37
- Serialize: 27
- Requirements: 24

### **Cluster 7: BST Operations**
*Standard BST functions*
- CRUD: 30, 32, 33
- Search Properties: 31, 34, 38

### **Cluster 8: BST Validation & Correction**
*Ensuring BST properties*
- Validation: 35
- Correction: 41
- Finding BST: 42

### **Cluster 9: Space Optimization**
*Constant space algorithms*
- Morris: 28, 29

---

## ğŸ’¡ **PROBLEM PAIRING** *(Similar Concepts)*

**Pair 1:** Inorder (1) â†” Preorder (2) â†” Postorder (3)

**Pair 2:** Morris Inorder (28) â†” Morris Preorder (29)

**Pair 3:** Top View (15) â†” Bottom View (16)

**Pair 4:** Right View (17) â†” Left View (17)

**Pair 5:** Construct from Pre+In (25) â†” Construct from Post+In (26)

**Pair 6:** LCA in BT (23) â†” LCA in BST (36)

**Pair 7:** Diameter (9) â†” Maximum Path Sum (10)

**Pair 8:** Floor in BST (31) â†” Ceil in BST (31)

**Pair 9:** Kth Smallest (34) â†” Kth Largest (34)

**Pair 10:** Inorder Successor (38) â†” Inorder Predecessor (38)

---

## ğŸ” **BY DIFFICULTY LEVEL**

### **ğŸŸ¢ Easy** (Beginner-Friendly)
- Problems: 1, 2, 3, 4, 6, 7, 8, 11, 17, 30, 32, 35

### **ğŸŸ¡ Medium** (Core Concepts)
- Problems: 5, 9, 12, 13, 14, 15, 16, 18, 19, 21, 23, 24, 25, 26, 27, 31, 33, 34, 36, 37, 38, 39, 40, 42

### **ğŸ”´ Hard** (Advanced Techniques)
- Problems: 10, 20, 22, 28, 29, 41

---

## ğŸ“ **TECHNIQUE-WISE GROUPING**

### **Recursion (DFS)**
â†’ Problems: 1, 2, 3, 6, 7, 8, 9, 10, 11, 18, 23, 25, 26, 30, 35, 36

### **Iteration with Stack**
â†’ Problems: 1, 2, 3, 5

### **BFS (Queue)**
â†’ Problems: 4, 12, 14, 15, 16, 17, 19, 20, 21

### **Morris Traversal**
â†’ Problems: 28, 29

### **Hash Map / Map**
â†’ Problems: 14, 15, 16

### **Two Pointers**
â†’ Problems: 40

### **Serialization**
â†’ Problems: 27

### **Inorder Property (BST)**
â†’ Problems: 34, 35, 38, 39, 41

---

## ğŸ“š **PATTERN RECOGNITION GUIDE**

### **When you see: "Traverse tree in order..."**
â†’ Use: DFS (Inorder/Preorder/Postorder) or BFS (Level Order) (Problems 1-4)

### **When you see: "Find depth/height..."**
â†’ Use: Recursion with max of subtrees + 1 (Problem 6)

### **When you see: "Check if trees are same/symmetric..."**
â†’ Use: Recursive comparison (Problems 7, 11)

### **When you see: "Balanced tree..."**
â†’ Use: Check height difference at each node (Problem 8)

### **When you see: "Path from root to node..."**
â†’ Use: DFS with path tracking (Problem 18)

### **When you see: "Lowest common ancestor..."**
â†’ Use: Recursive search in both subtrees (Problems 23, 36)

### **When you see: "View of tree (top/bottom/left/right)..."**
â†’ Use: Level order with tracking (Problems 15-17)

### **When you see: "Vertical order..."**
â†’ Use: BFS with column tracking (Problem 14)

### **When you see: "Zigzag traversal..."**
â†’ Use: Level order with alternating direction (Problem 12)

### **When you see: "Construct tree from traversals..."**
â†’ Use: Recursion with index management (Problems 25, 26)

### **When you see: "Serialize/Deserialize..."**
â†’ Use: Preorder with null markers (Problem 27)

### **When you see: "O(1) space traversal..."**
â†’ Use: Morris Traversal (Problems 28, 29)

### **When you see: "Kth smallest/largest in BST..."**
â†’ Use: Inorder traversal (Problem 34)

### **When you see: "Validate BST..."**
â†’ Use: Inorder or Range checking (Problem 35)

### **When you see: "Two sum in BST..."**
â†’ Use: Inorder + Two pointers (Problem 40)

### **When you see: "Two nodes swapped in BST..."**
â†’ Use: Inorder to find violations (Problem 41)

---

## ğŸ† **MILESTONE PROBLEMS**
*Master these to understand core patterns*

1. **Inorder Traversal (1)** - Foundation of tree traversal
2. **Level Order Traversal (4)** - BFS on trees
3. **Maximum Depth (6)** - Basic recursion
4. **Diameter of Tree (9)** - Path through node
5. **Maximum Path Sum (10)** - Complex path problem
6. **Zigzag Traversal (12)** - Level order variant
7. **Vertical Order (14)** - Coordinate-based traversal
8. **LCA (23)** - Finding common ancestor
9. **Construct from Traversals (25)** - Building trees
10. **Serialize/Deserialize (27)** - Tree encoding
11. **Morris Traversal (28)** - Space optimization
12. **Validate BST (35)** - BST property checking
13. **Kth Smallest in BST (34)** - Inorder application
14. **Largest BST in BT (42)** - Complex BST problem

---

## ğŸ—ºï¸ **PROBLEM BREAKDOWN BY TYPE**

### **Traversal Problems** (7 problems)
â†’ 1, 2, 3, 4, 5, 28, 29

### **Property Checking** (5 problems)
â†’ 7, 8, 11, 35, 41

### **Height/Depth/Diameter** (3 problems)
â†’ 6, 9, 21

### **Path & Sum** (4 problems)
â†’ 10, 18, 19, 20

### **View Problems** (6 problems)
â†’ 12, 13, 14, 15, 16, 17

### **LCA Problems** (2 problems)
â†’ 23, 36

### **Construction** (4 problems)
â†’ 24, 25, 26, 27

### **BST Operations** (8 problems)
â†’ 30, 31, 32, 33, 34, 37, 38, 39

### **BST Special** (3 problems)
â†’ 40, 41, 42

### **Width & Counting** (2 problems)
â†’ 21, 22

---

## ğŸ“Š **TOTAL STATISTICS**

- **Total Problems:** 43
- **Tree Traversals:** 7 problems (16%)
- **Tree Properties & Advanced:** 17 problems (40%)
- **Tree Construction & Morris:** 7 problems (16%)
- **BST Problems:** 13 problems (30%)
- **Easy:** 12 problems (28%)
- **Medium:** 24 problems (56%)
- **Hard:** 7 problems (16%)

---

## ğŸ”„ **PREREQUISITE RELATIONSHIPS**

### **Master First (Foundation):**
1, 2, 3, 4 â†’ All basic traversals

### **Then Learn (Properties):**
6, 7, 8, 11 â†’ Tree characteristics

### **Build Upon (Paths):**
9, 10, 18, 23 â†’ Path-finding problems

### **Advanced Views:**
12, 13, 14, 15, 16, 17 â†’ Different perspectives

### **Construction:**
25, 26, 27 â†’ Building trees

### **BST Basics:**
30, 32, 33, 35 â†’ BST operations

### **BST Advanced:**
31, 34, 36, 37, 38, 39, 40 â†’ Complex BST

### **Expert Level:**
28, 29, 41, 42 â†’ Morris and corrections

---

## ğŸ¯ **COMMON PATTERNS & TEMPLATES**

### **Template 1: Recursive DFS (Inorder)**
```python
def inorder(root):
    if not root:
        return []
    return inorder(root.left) + [root.val] + inorder(root.right)
```
â†’ Used in: 1, 34, 38

### **Template 2: Iterative DFS with Stack**
```python
def inorder(root):
    stack, result = [], []
    curr = root
    while curr or stack:
        while curr:
            stack.append(curr)
            curr = curr.left
        curr = stack.pop()
        result.append(curr.val)
        curr = curr.right
    return result
```
â†’ Used in: 1, 2, 3

### **Template 3: Level Order (BFS)**
```python
def levelOrder(root):
    if not root:
        return []
    queue = deque([root])
    result = []
    while queue:
        level = []
        for _ in range(len(queue)):
            node = queue.popleft()
            level.append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        result.append(level)
    return result
```
â†’ Used in: 4, 12, 15, 16, 17

### **Template 4: Height/Depth**
```python
def maxDepth(root):
    if not root:
        return 0
    return 1 + max(maxDepth(root.left), maxDepth(root.right))
```
â†’ Used in: 6, 8, 9

### **Template 5: Path Finding**
```python
def findPath(root, target):
    if not root:
        return False
    if root.val == target:
        return [root.val]
    
    left = findPath(root.left, target)
    if left:
        return [root.val] + left
    
    right = findPath(root.right, target)
    if right:
        return [root.val] + right
    
    return False
```
â†’ Used in: 18, 23

### **Template 6: LCA**
```python
def lowestCommonAncestor(root, p, q):
    if not root or root == p or root == q:
        return root
    
    left = lowestCommonAncestor(root.left, p, q)
    right = lowestCommonAncestor(root.right, p, q)
    
    if left and right:
        return root
    return left if left else right
```
â†’ Used in: 23, 36

### **Template 7: Morris Traversal**
```python
def morrisInorder(root):
    result = []
    curr = root
    while curr:
        if not curr.left:
            result.append(curr.val)
            curr = curr.right
        else:
            # Find predecessor
            pred = curr.left
            while pred.right and pred.right != curr:
                pred = pred.right
            
            if not pred.right:
                pred.right = curr  # Create thread
                curr = curr.left
            else:
                pred.right = None  # Remove thread
                result.append(curr.val)
                curr = curr.right
    return result
```
â†’ Used in: 28, 29

### **Template 8: BST Search**
```python
def searchBST(root, val):
    if not root or root.val == val:
        return root
    return searchBST(root.left, val) if val < root.val else searchBST(root.right, val)
```
â†’ Used in: 30, 31, 36

### **Template 9: BST Validation**
```python
def isValidBST(root, min_val=float('-inf'), max_val=float('inf')):
    if not root:
        return True
    if not (min_val < root.val < max_val):
        return False
    return (isValidBST(root.left, min_val, root.val) and 
            isValidBST(root.right, root.val, max_val))
```
â†’ Used in: 35, 41, 42

---

## ğŸŒŸ **KEY TREE INSIGHTS**

### **Traversal Time Complexities:**
- All traversals: O(n) time
- Recursive: O(h) space (call stack)
- Iterative: O(h) space (explicit stack)
- Morris: O(1) space (modifies tree temporarily)

### **Tree Height:**
- Balanced tree: O(log n)
- Skewed tree: O(n)

### **BST Properties:**
- Inorder traversal gives sorted order
- Search/Insert/Delete: O(h)
- Balanced BST: O(log n) operations

### **Common Tree Patterns:**
1. **Top-down recursion**: Pass info from parent to child
2. **Bottom-up recursion**: Return info from child to parent
3. **Level order**: Use queue for BFS
4. **Path problems**: Track path during traversal

---

## ğŸ¯ **QUICK REFERENCE BY NUMBER**

**1-5:** Basic Traversals  
**6-11:** Tree Properties  
**12-22:** Advanced Traversals & Views  
**23-27:** LCA & Construction  
**28-29:** Morris Traversal  
**30-42:** Binary Search Tree Problems

---

## âœ… **COMPLETENESS STATUS**

### **Coverage: 95% COMPLETE** âœ“âœ“âœ“

**What You Have:**
- âœ… All traversal types (DFS, BFS, Morris)
- âœ… All tree properties (depth, diameter, balance, symmetry)
- âœ… All view problems (top, bottom, left, right, vertical, boundary)
- âœ… Path and distance problems
- âœ… Construction from traversals
- âœ… Serialization/Deserialization
- âœ… Complete BST operations (CRUD, search, validation)
- âœ… Advanced BST (Kth element, LCA, iterator, two sum, correction)

**Minor Missing Topics (5%):**
- â­• **N-ary Tree** problems (2-3 problems)
- â­• **Trie (Prefix Tree)** - separate category
- â­• **Segment Tree / Fenwick Tree** - advanced

**Verdict:** OUTSTANDING tree coverage! All interview essentials covered! ğŸ‰ğŸŒ³

---

## ğŸ“ **INTERVIEW FREQUENCY**

### **Very High Frequency** â­â­â­
â†’ 1, 4, 6, 23, 25, 27, 35

### **High Frequency** â­â­
â†’ 2, 3, 7, 8, 9, 11, 17, 30, 32, 33, 34

### **Medium Frequency** â­
â†’ 5, 10, 12, 13, 14, 15, 16, 18, 19, 21, 26, 31, 36, 37, 38, 39, 40, 42

### **Low Frequency**
â†’ 20, 22, 24, 28, 29, 41

**Most Asked:** Inorder (1), Level Order (4), Max Depth (6), LCA (23), Validate BST (35), Serialize (27)
