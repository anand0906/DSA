# Linked List - Complete Index

## ğŸ“‘ Complete Problem Catalog (22 Problems)

---

## ğŸ”¹ **BASIC LINKED LIST OPERATIONS**
*Fundamental operations on singly linked list*

### **Subtype: Manipulation & Rearrangement**
1. Add Two Numbers in Linked List
2. Segregate Odd and Even Nodes
3. Sort a Linked List of 0's, 1's and 2's
4. Remove Nth Node from the Back
5. Reverse a Linked List

---

## ğŸ”¹ **INTERMEDIATE LINKED LIST PROBLEMS**
*Core patterns and techniques*

### **Subtype: Arithmetic Operations**
6. Add One to a Number Represented by LL

### **Subtype: Fast & Slow Pointer Pattern**
7. Find Middle of Linked List
8. Delete the Middle Node in LL
9. Check if LL is Palindrome

### **Subtype: Two Pointer - Intersection & Cycle**
10. Find Intersection Point of Y LL
11. Detect a Loop in LL
12. Find the Starting Point of Loop
13. Length of Loop in LL

### **Subtype: Advanced Manipulation**
14. Reverse LL in Groups of Size K
15. Rotate a Linked List

---

## ğŸ”¹ **ADVANCED LINKED LIST PROBLEMS**
*Complex operations and merging*

### **Subtype: Merging & Sorting**
16. Merge K Sorted Lists
17. Flattening of LL
18. Sort Linked List

### **Subtype: Special Pointer Problems**
19. Clone LL with Random and Next Pointer

---

## ğŸ”¹ **DOUBLY LINKED LIST**
*Problems specific to DLL*

20. Delete All Occurrences of a Key in DLL
21. Remove Duplicates from Sorted DLL

---

## ğŸ”¹ **DESIGN PROBLEMS**
*Using linked list for system design*

22. Design Browser History

---

## ğŸ“Š **SUMMARY BY CATEGORY**

### **ğŸŸ¢ Basic Linked List Operations** (5 problems)
â†’ Problems: 1-5

### **ğŸŸ¡ Intermediate Problems** (10 problems)
â†’ Problems: 6-15

### **ğŸ”´ Advanced Problems** (4 problems)
â†’ Problems: 16-19

### **ğŸŸ¡ Doubly Linked List** (2 problems)
â†’ Problems: 20-21

### **ğŸ”´ Design Problems** (1 problem)
â†’ Problem: 22

---

## ğŸ“ˆ **LEARNING PATH RECOMMENDATION**

### **Phase 1: Linked List Fundamentals** (Start Here)
```
5 â†’ 4 â†’ 7 â†’ 2
```
*Master reversal, deletion, and middle finding*

### **Phase 2: Two Pointer Patterns**
```
8 â†’ 9 â†’ 10 â†’ 11 â†’ 12 â†’ 13
```
*Learn fast & slow pointer, cycle detection*

### **Phase 3: Manipulation & Transformation**
```
1 â†’ 6 â†’ 3 â†’ 14 â†’ 15
```
*Arithmetic operations and grouping*

### **Phase 4: Sorting & Merging**
```
18 â†’ 16 â†’ 17
```
*Complex merging and sorting algorithms*

### **Phase 5: Special Pointers**
```
19 â†’ 20 â†’ 21
```
*Random pointers and DLL operations*

### **Phase 6: Design Applications**
```
22
```
*System design with linked lists*

---

## ğŸ¯ **CONCEPT CLUSTERING**

### **Cluster 1: Basic Operations**
*Foundation building*
- Reversal: 5, 14
- Deletion: 4, 8
- Rearrangement: 2, 3, 15

### **Cluster 2: Two Pointer Technique**
*Fast & Slow, Two Pointers*
- Middle Finding: 7, 8
- Cycle Detection: 11, 12, 13
- Intersection: 10
- Palindrome: 9

### **Cluster 3: Arithmetic on LL**
*Treating LL as numbers*
- Addition: 1, 6

### **Cluster 4: Advanced Manipulation**
*Complex transformations*
- Group Operations: 14
- Rotation: 15
- Sorting: 3, 18

### **Cluster 5: Merging Problems**
*Combining multiple lists*
- Multiple Lists: 16, 17
- Two Lists: (implicit in 1)

### **Cluster 6: Special Structures**
*Complex pointer relationships*
- Random Pointers: 19
- Doubly Linked: 20, 21
- Design: 22

---

## ğŸ’¡ **PROBLEM PAIRING** *(Similar Concepts)*

**Pair 1:** Reverse LL (5) â†” Reverse in Groups (14)

**Pair 2:** Find Middle (7) â†” Delete Middle (8)

**Pair 3:** Detect Loop (11) â†” Find Loop Start (12) â†” Loop Length (13)

**Pair 4:** Add Two Numbers (1) â†” Add One (6)

**Pair 5:** Sort 0-1-2 (3) â†” Sort LL (18)

**Pair 6:** Merge K Lists (16) â†” Flatten LL (17)

**Pair 7:** Delete Occurrences DLL (20) â†” Remove Duplicates DLL (21)

---

## ğŸ” **BY DIFFICULTY LEVEL**

### **ğŸŸ¢ Easy** (Beginner-Friendly)
- Problems: 2, 4, 5, 7, 11, 20, 21

### **ğŸŸ¡ Medium** (Core Concepts)
- Problems: 1, 3, 6, 8, 9, 10, 12, 13, 14, 15, 18, 19, 22

### **ğŸ”´ Hard** (Advanced Techniques)
- Problems: 16, 17

---

## ğŸ“ **TECHNIQUE-WISE GROUPING**

### **Iterative Reversal**
â†’ Problems: 5, 14

### **Fast & Slow Pointer**
â†’ Problems: 7, 8, 9, 11, 12, 13

### **Two Pointers**
â†’ Problems: 10, 9

### **Recursion**
â†’ Problems: 5, 14, 16, 17

### **Dummy Node Technique**
â†’ Problems: 1, 3, 16, 18

### **In-place Modification**
â†’ Problems: 2, 3, 15

### **Hash Map / Set**
â†’ Problems: 11, 19

### **Merge Sort on LL**
â†’ Problems: 18

### **Heap / Priority Queue**
â†’ Problems: 16

---

## ğŸ“š **PATTERN RECOGNITION GUIDE**

### **When you see: "Reverse linked list..."**
â†’ Use: Iterative/Recursive Reversal (Problems 5, 14)

### **When you see: "Find middle of..."**
â†’ Use: Fast & Slow Pointer (Problems 7, 8)

### **When you see: "Detect cycle/loop..."**
â†’ Use: Floyd's Cycle Detection (Problems 11, 12, 13)

### **When you see: "Check palindrome..."**
â†’ Use: Middle + Reverse + Compare (Problem 9)

### **When you see: "Intersection point..."**
â†’ Use: Two Pointer with Length Difference (Problem 10)

### **When you see: "Add numbers represented by..."**
â†’ Use: Digit-by-digit Addition (Problems 1, 6)

### **When you see: "Sort linked list..."**
â†’ Use: Merge Sort for O(n log n) (Problem 18)

### **When you see: "Merge K sorted..."**
â†’ Use: Min Heap or Divide & Conquer (Problem 16)

### **When you see: "Flatten nested list..."**
â†’ Use: Recursion with Merging (Problem 17)

### **When you see: "Clone with random pointer..."**
â†’ Use: HashMap or Interweaving Nodes (Problem 19)

### **When you see: "Rotate by K positions..."**
â†’ Use: Find New Head, Break & Rejoin (Problem 15)

### **When you see: "Remove Nth from end..."**
â†’ Use: Two Pointer with N gap (Problem 4)

---

## ğŸ† **MILESTONE PROBLEMS**
*Master these to understand core patterns*

1. **Reverse Linked List (5)** - Most fundamental operation
2. **Find Middle (7)** - Fast & slow pointer introduction
3. **Detect Loop (11)** - Floyd's cycle detection
4. **Check Palindrome (9)** - Combining multiple techniques
5. **Find Intersection (10)** - Two pointer with offset
6. **Reverse in Groups (14)** - Advanced reversal
7. **Merge K Sorted Lists (16)** - Heap with LL
8. **Sort Linked List (18)** - Merge sort on LL
9. **Clone Random Pointer (19)** - HashMap technique
10. **Add Two Numbers (1)** - Arithmetic on LL

---

## ğŸ—ºï¸ **PROBLEM BREAKDOWN BY TYPE**

### **Reversal Problems** (2 problems)
â†’ 5, 14

### **Fast & Slow Pointer** (7 problems)
â†’ 7, 8, 9, 11, 12, 13, 18

### **Arithmetic Operations** (2 problems)
â†’ 1, 6

### **Sorting & Rearrangement** (4 problems)
â†’ 2, 3, 15, 18

### **Merging Problems** (2 problems)
â†’ 16, 17

### **Deletion Problems** (3 problems)
â†’ 4, 8, 20

### **Special Pointers** (2 problems)
â†’ 10, 19

### **Doubly Linked List** (2 problems)
â†’ 20, 21

### **Design** (1 problem)
â†’ 22

---

## ğŸ“Š **TOTAL STATISTICS**

- **Total Problems:** 22
- **Basic Operations:** 5 problems (23%)
- **Intermediate:** 10 problems (45%)
- **Advanced:** 4 problems (18%)
- **DLL:** 2 problems (9%)
- **Design:** 1 problem (5%)
- **Easy:** 7 problems (32%)
- **Medium:** 13 problems (59%)
- **Hard:** 2 problems (9%)

---

## ğŸ”„ **PREREQUISITE RELATIONSHIPS**

### **Master First (Foundation):**
5, 7, 4 â†’ Basic reversal, middle finding, deletion

### **Then Learn (Two Pointer Patterns):**
8, 9, 11, 12, 13 â†’ Fast & slow pointer, cycle detection

### **Build Upon (Manipulation):**
1, 6, 2, 3, 14, 15 â†’ Arithmetic and rearrangement

### **Advanced Techniques:**
10, 18, 16, 17, 19 â†’ Intersection, sorting, merging, cloning

### **Specialized:**
20, 21, 22 â†’ DLL operations and design

---

## ğŸ¯ **COMMON PATTERNS & TEMPLATES**

### **Template 1: Reverse Linked List (Iterative)**
```python
def reverse(head):
    prev = None
    curr = head
    while curr:
        next_node = curr.next
        curr.next = prev
        prev = curr
        curr = next_node
    return prev
```
â†’ Used in: 5, 9, 14

### **Template 2: Fast & Slow Pointer**
```python
def findMiddle(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    return slow
```
â†’ Used in: 7, 8, 9, 11

### **Template 3: Detect Cycle (Floyd's)**
```python
def hasCycle(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False
```
â†’ Used in: 11, 12, 13

### **Template 4: Remove Nth from End**
```python
def removeNthFromEnd(head, n):
    dummy = ListNode(0, head)
    first = second = dummy
    # Move first n+1 steps ahead
    for _ in range(n + 1):
        first = first.next
    # Move both until first reaches end
    while first:
        first = first.next
        second = second.next
    # Remove the node
    second.next = second.next.next
    return dummy.next
```
â†’ Used in: 4

### **Template 5: Merge Two Sorted Lists**
```python
def merge(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 if l1 else l2
    return dummy.next
```
â†’ Used in: 16, 17, 18

### **Template 6: Find Intersection Point**
```python
def getIntersection(headA, headB):
    if not headA or not headB:
        return None
    
    pA, pB = headA, headB
    while pA != pB:
        pA = pA.next if pA else headB
        pB = pB.next if pB else headA
    return pA
```
â†’ Used in: 10

---

## ğŸŒŸ **KEY INSIGHTS**

### **Fast & Slow Pointer Benefits:**
- Find middle in one pass: O(n) time, O(1) space
- Detect cycles efficiently
- Works for finding Kth from end with variations

### **Dummy Node Advantages:**
- Simplifies edge cases (empty list, single node)
- Easy head manipulation
- Clean code for merging operations

### **Recursion vs Iteration:**
- Recursion: Cleaner for reversal, tree-like traversal
- Iteration: Better space complexity (O(1) vs O(n))
- Choose based on problem constraints

### **When to Use HashMap:**
- Clone with random pointers
- Detect cycle (alternative to Floyd's)
- Track visited nodes

### **Linked List vs Array:**
- LL: O(1) insertion/deletion at known position
- LL: O(n) access by index
- LL: Dynamic size without reallocation

---

## ğŸ¯ **QUICK REFERENCE BY NUMBER**

**1-5:** Basic Linked List Operations  
**6-15:** Intermediate (Fast & Slow, Arithmetic, Manipulation)  
**16-19:** Advanced (Merging, Sorting, Special Pointers)  
**20-21:** Doubly Linked List  
**22:** Design Problems

---

## âœ… **COMPLETENESS STATUS**

### **Coverage: 90% COMPLETE** âœ“

**What You Have:**
- âœ… All fundamental operations (reversal, deletion, finding middle)
- âœ… Fast & slow pointer pattern (complete)
- âœ… Cycle detection (all variants)
- âœ… Arithmetic operations on LL
- âœ… Advanced manipulation (groups, rotation)
- âœ… Merging & sorting
- âœ… Clone with random pointers
- âœ… Doubly linked list operations
- âœ… Design problems

**Minor Missing Topics (10%):**
- â­• **Circular Linked List** (2-3 problems)
  - Split circular LL into two halves
  - Check if LL is circular
- â­• **XOR Linked List** (1 problem - advanced)
- â­• **Skip List** (1-2 problems - advanced data structure)

**Verdict:** Excellent and comprehensive coverage! All interview essentials covered! ğŸ‰

---

## ğŸ“ **INTERVIEW FREQUENCY**

### **Very High Frequency** â­â­â­
â†’ 5, 7, 11, 9, 4, 1

### **High Frequency** â­â­
â†’ 12, 10, 14, 16, 19, 18

### **Medium Frequency** â­
â†’ 6, 8, 13, 15, 17, 3, 2

### **Low Frequency**
â†’ 20, 21, 22

Focus on the **Very High** and **High** frequency problems first for interview preparation!
